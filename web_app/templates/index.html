{% extends 'base.html' %}

{% block head %}
<script type="text/javascript" src="{{ url_for('static', filename='visual.js') }}"></script>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
  <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
  <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
  <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
<title>Trade Space Exploration for The Software-Defined Farm</title>
{% endblock %}

{% block body %}
<div class="content" style="width: 30%">
    <h1 style="text-align: center">Trade Space Exploration</h1>
    <h4 style="text-align: center">For The Software-Defined Farm</h4>
    <p style="text-align: center; font-family: 'Arial Narrow'">
        <br>Tradespace Exploration is a decision-support tool developed to find the optimal architectural designs for The Software Defined Farm using a Robust Decision Making framework. <br><br>
        This tool has the capability of identifying potential robust strategies for the architectural design, analyzing the vulnerability of each strategy, and evaluate their performance in deep uncertainties.
    </p>
</div>
<div class="content">
    <div class="area" id="parameter">
        <h2 style="text-align: center">Parameters:</h2>
        <div class="form">
            <form action="/" method="POST" >
                <label for="crop">Crop Type: </label>
                <input type="text" name="crop" id="crop" value="0"><br>
                <label for="latitude">Latitude: </label>
                <input type="text" name="latitude" id="latitude" value="45"><br>
                <label for="numOfUsers">User Amount: </label>
                <input type="text" name="numOfUsers" id="numOfUsers" value="1000"><br>
                <label for="sampEn">SampEn: </label>
                <input type="text" name="sampEn" id="sampEn" value="2.68"><br>
                <label for="rainfall">Precipitation: </label>
                <input type="text" name="rainfall" id="rainfall" value="1302.775"><br>
                <text><br></text>
                <div id="metrics" hidden>
                    <p>Metrics Range</p>
                    <p>
                      <label for="cost">Cost:</label>
                      <input type="text" id="cost" readonly style="border:0; color:#4668f5; font-weight:bold;">
                    </p>
                    <div id="cost-range"></div>
                    <p>
                      <label for="performance">Performance:</label>
                      <input type="text" id="performance" readonly style="border:0; color:#4668f5; font-weight:bold;">
                    </p>
                    <div id="perf-range"></div>
                    <p>
                      <label for="risk">Risk:</label>
                      <input type="text" id="risk" readonly style="border:0; color:#4668f5; font-weight:bold;">
                    </p>
                    <div id="risk-range"></div>
                </div>
            </form>
        </div>
    </div>

    <div class="area" id="function">
        <h2 style="text-align: center">Functions:</h2>
        <button class="function_bt" id="generate_ts">Generate TradeSpace</button>
        <button class="function_bt" id="pareto_ts" disabled="true">Calculate Pareto Front</button>
        <button class="function_bt" id="setup_model">Update Model</button>
        <button class="function_bt" id="optimize_ts" disabled="true">Optimize in Scenario</button>
        <button class="function_bt" id="policy_eval" disabled="true">Evaluate Policy in Uncertainty</button>
        <button class="function_bt" id="SA" disabled="true">Sensitivity Analysis</button>
    </div>

    <div class="area" id="log">
        <h2 style="text-align: center">Log:</h2>
        <textarea id="log_area"></textarea>
    </div>

    <div class="output" id="output" style="text-align: center">
        <h2 style="text-align: center">Output:</h2>
        <div id="output_box" class="output"></div>
    </div>

<!--    <div class="output" id="visual" style="text-align: center">-->
<!--        <h2 style="text-align: center">Visualizations:</h2>-->
<!--        <div id='eval_vis' class="vis"></div>-->
<!--    </div>-->

<!--    <div class="output" id="vis1" hidden>-->
<!--        <h2 style="text-align: center">Trade Space Visualization:</h2>-->
<!--        <svg id="scatterplot" height="400" width="400" style="margin: 20px auto; display: block;" >-->
<!--    </div>-->

</div>

<script id="controller">
    let crop = document.getElementById("crop")
    let latitude = document.getElementById("latitude")
    let numOfUsers = document.getElementById("numOfUsers")
    let sampEn = document.getElementById("sampEn")
    let rainfall = document.getElementById("rainfall")

    let cost_range = [0, 1000];
    let perf_range = [0, 1500];
    let risk_range = [0, 1];


    let log = document.getElementById("log_area")
    let btn_generate = document.getElementById("generate_ts")
    let btn_pareto_ts = document.getElementById("pareto_ts")
    let btn_update_model = document.getElementById("setup_model")
    let btn_optimize = document.getElementById("optimize_ts")
    let btn_policy_eval = document.getElementById("policy_eval")
    let btn_sa = document.getElementById("SA")
    let output_area = document.getElementById("output_box")
    let metric_area = document.getElementById("metrics")
    var log_count = 1;


    function updateTextInput() {
        let perf = document.getElementById('performance').value
        let cost = document.getElementById('cost').value
        let risk = document.getElementById('risk').value

        document.getElementById('ratio').innerText= 'Cost : Perf : Risk = ' + cost + ':' + perf + ':' + risk;
    }

    function insertText(text) {
        log.value = "**************************************************\n" + "[ " + log_count + " ]  " + text + "\n" + "\n" + log.value;
        log_count ++;
    }

    function insertResults(content, format, link){
        if(format === 'text'){
            let p = document.createElement('p');
            let node = document.createTextNode(content);
            p.appendChild(node);
            p.class = "results"
            output_area.appendChild(p);
            return p;
        }
        if (format === 'link'){
            let a = document.createElement('a');
            let node = document.createTextNode(content);
            a.appendChild(node);
            a.href = link;
            output_area.appendChild(a);
            return a;
        }
        if(format === 'img'){
            let img = document.createElement('IMG');
            img.src = link;
            img.alt = "plot"
            output_area.appendChild(img);
            return img;
        }
        if(format === 'h3'){
            let p = document.createElement('h3');
            let node = document.createTextNode(content);
            p.appendChild(node);
            output_area.appendChild(p);
            return p;
        }
        if (format === 'visual'){
            let vis = document.createElement('div');
            vis.id = content;
            vis.class = 'vis';
            output_area.appendChild(vis);
            return vis;
        }
    }

    function updateMetricRange(){
        $( "#cost-range" ).slider({
            range: true,
            min: 0,
            max: 1000,
            values: [ 0, 1000 ],
            slide: function( event, ui ) {
                $( "#cost" ).val( ui.values[ 0 ] + "k ~ " + ui.values[ 1 ] + "k" );
                cost_range = ui.values;
            }
        });
        $( "#cost" ).val( $( "#cost-range" ).slider( "values", 0 ) + "k ~ " + $( "#cost-range" ).slider( "values", 1 ) + "k" );


        $( "#perf-range" ).slider({
            range: true,
            min: 0,
            max: 1500,
            values: [ 0, 1500 ],
            slide: function( event, ui ) {
                $( "#performance" ).val( ui.values[ 0 ] + " ~ " + ui.values[ 1 ] );
                perf_range = ui.values;
            }
        });
        $( "#performance" ).val( $( "#perf-range" ).slider( "values", 0 ) + " ~ " + $( "#perf-range" ).slider( "values", 1 ) );

        $( "#risk-range" ).slider({
            range: true,
            min: 0,
            max: 1,
            values: [ 0, 1 ],
            slide: function( event, ui ) {
                $( "#risk" ).val( ui.values[ 0 ] + " ~ " + ui.values[ 1 ] );
                risk_range = ui.values;
            }
        });
        $( "#risk" ).val( $( "#risk-range" ).slider( "values", 0 ) + " ~ " + $( "#risk-range" ).slider( "values", 1 ) );
    }


    btn_generate.addEventListener("click", function (){
        insertText("Generating TradeSpace, Please wait for outputs...");
        btn_generate.disabled = true;
        insertResults("----------- Generate Trade Space -----------", "h3", null);
        let p = insertResults("Pending results......", "text", null);
        fetch("/generate")
            .then(res => {
                let ts_len = res.headers.get('ts_len');
                console.log(ts_len);
                p.innerText = "Found " + ts_len + " possible policies in the trade space.";
                insertResults("The trade space is saved in:", "text", null);
                insertResults("TradeSpace", "link", "{{ url_for('static', filename='tradespace_enumeration.csv') }}");
                insertResults("         ", "text", null);
                btn_pareto_ts.disabled = false;
            });

    });

    btn_pareto_ts.addEventListener("click", function (){
        insertText("Calculating Pareto Fronts, Please wait for outputs...");
        btn_pareto_ts.disabled = true;
        insertResults("----------- Calculate Pareto Front -----------", "h3", null);
        let p = insertResults("Pending results......", "text", null);
        fetch("/pareto")
            .then(res => {
                let ps_len = res.headers.get('ps_len');
                console.log(ps_len);
                p.innerText = "Found " + ps_len + " pareto optimal policies in the trade space without uncertainty.";
                insertResults("Pareto Front is saved here:", "text", null);
                insertResults("Pareto Front without uncertainty", "link", "{{ url_for('static', filename='pareto_set.csv') }}");
                insertResults("", "img", "{{url_for('static', filename='pareto_ts.png')}}");
                let id = 'pareto_set' + log_count;
                insertResults(id, 'visual', '');
                let hover_txt = insertResults("", "text", null);
                plot_pareto_front(id);
                insertResults("       ", "text", null);
                btn_update_model.disabled = false;
                updateMetricRange();
                metric_area.hidden = false;
            });
    });

    btn_update_model.addEventListener("click", function (){
        insertText("Updated Model");
        insertResults("----------- Update Uncertainty Model -----------", "h3", null);
        let p = insertResults("Pending results......", "text", null);
        let data = {rainfall: rainfall.value, latitude: latitude.value,
            numOfUsers: numOfUsers.value, sampEn: sampEn.value,
            crop: crop.value, cost_range: cost_range, perf_range: perf_range, risk_range: risk_range};
        fetch("/update_model", {
            method: 'POST',
            body: JSON.stringify(data),
            headers: new Headers({
                "content-type": "application/json"
            })
        }).then(res => {
                p.innerText = "The updated uncertainty model:";
                insertResults("Crop Type: " + crop.value, "text", null);
                insertResults("Latitude: " + latitude.value, "text", null);
                insertResults("Number of Users: " + numOfUsers.value, "text", null);
                insertResults("SampEn: " + sampEn.value, "text", null);
                insertResults("Precipitation: " + rainfall.value, "text", null);
                // insertResults("Metrics Priority Ratio = " + document.getElementById('ratio').innerText, "text", null);
                insertResults("Cost Range: " + cost_range[0] + "k ~ " + cost_range[1] + "k", "text", null);
                insertResults("Performance Range: " + perf_range[0] + " ~ " + perf_range[1], "text", null);
                insertResults("Risk Range: " + risk_range[0] + " ~ " + risk_range[1], "text", null);
                insertResults("       ", "text", null);
                btn_optimize.disabled = false;
            });
    });

    btn_optimize.addEventListener("click", function (){
        insertText("Optimizing pareto front based on uncertainty...");
        insertResults("----------- Pareto Front with Uncertainty -----------", "h3", null);
        let p = insertResults("Pending results......", "text", null);
        fetch("/optimize")
            .then(res => {
                let ps_len = res.headers.get('ps_len');
                p.innerText = "With the defined uncertainty model, found " + ps_len + " optimal policies:" ;
                insertResults("Optimal Set with Uncertainty", "link", "{{ url_for('static', filename='rhodium_optimize.csv') }}");
                let id = 'optimize' + log_count;
                insertResults(id, 'visual', '');
                plot_optimize(id);
                btn_policy_eval.disabled = false;
            });
    });

    btn_policy_eval.addEventListener("click", function (){
        insertText("Runing Scenario Discovery, Please wait for outputs...");
        insertResults("----------- Optimal Policies in Uncertain States-Of-Worlds -----------", "h3", null);
        let p = insertResults("Pending results......", "text", null);
        fetch("/policy_eval")
            .then(res => {
                p.innerText = "Results of evaluating the optimal policies in an uncertain environment modeled by 1000 SOWs:" ;
                insertResults("Optimal Set with Uncertainty", "link", "{{ url_for('static', filename='rhodium_policy_eval.csv') }}");
                let id = 'policy_eval' + log_count;
                let div = insertResults(id, 'visual', '');
                plot_policy_eval(id);
                btn_sa.disabled = false;
            });
    });

    btn_sa.addEventListener("click", function (){
        insertText("Generating Sensitivity Analysis...");
        insertResults("----------- Sensitivity Analysis -----------", "h3", null);
        let p = insertResults("Pending results......", "text", null);
        fetch("/sa")
            .then(res => {

                p.innerText = "SA:" ;
            });
    });

</script>

<script id="plotly">

    function plot_pareto_front(div) {
        Plotly.d3.csv("{{ url_for('static', filename='pareto_set.csv') }}", function (err, ts) {

            function unpack(rows, key) {
                return rows.map(function (row) {
                    return row[key];
                });
            }

            function unpack_size(rows, key) {
                return rows.map(function (row) {
                    return Math.round(row[key] * 10) - 18;
                });
            }

            var data = [{
                x: unpack(ts, 'perf'),
                y: unpack(ts, 'cost'),
                z: unpack(ts, 'risk'),
                text: unpack(ts, 'policy_names'),
                mode: 'markers',
                type: 'scatter3d',
                marker: {
                    color: 'rgb(24,182,69)',
                    opacity: 0.6,
                    size: 2
                },
                hovertemplate:
                "Cost: %{y}<br>" +
                "Performance: %{x}<br>" +
                "Risk: %{z}<br>"
            },
                // {
                //     type: 'scatter3d',
                //     mode: "markers",
                //     x: unpack(ps, 'performance'),
                //     y: unpack(ps, 'cost'),
                //     z: unpack(ps, 'risk'),
                //     marker: {
                //         color: 'rgb(116,255,17)',
                //         opacity: 0.8,
                //         size: 3
                //     }
                // }
            ];

            // Get metric range from dataset
            //console.log(data[0].y);
            // let costs = data[0].y.map(el => parseInt(el))
            // let perfs = data[0].x.map(el => parseInt(el))
            // cost_range = [Math.min(...costs), Math.max(...costs)]
            // perf_range = [Math.min(...perfs), Math.max(...perfs)]
            console.log(cost_range)

            var layout = {
                autosize: true,
                height: 800,
                scene: {
                    aspectratio: {
                        x: 1,
                        y: 1,
                        z: 1
                    },
                    camera: {
                        center: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        eye: {
                            x: 1.25,
                            y: 1.25,
                            z: 1.25
                        },
                        up: {
                            x: 0,
                            y: 0,
                            z: 1
                        }
                    },
                    xaxis: {
                        title: 'Performance',
                        type: 'linear',
                        zeroline: false
                    },
                    yaxis: {
                        title: 'Cost',
                        type: 'linear',
                        zeroline: false
                    },
                    zaxis: {
                        title: 'Risk',
                        type: 'linear',
                        zeroline: false
                    }
                },
                title: {
                    text: 'Pareto Front Zoomed In',
                    font: {
                        size: 18,
                    }
                }
            };

            Plotly.newPlot(div, data, layout, {displayModeBar: false});

            document.getElementById(div).on('plotly_click', function(data){
                var pts = '';
                for(var i=0; i < data.points.length; i++){
                    pts = 'Performance: '+data.points[i].x +'\n' +
                          'Cost: '+ data.points[i].y + '\n' +
                          'Risk: ' + data.points[i].z + '\n\n' +
                          'Policy: ' + data.points[i].text + '\n';
                }
                alert('Policy Selected:\n\n'+pts);
            });
        });
    }

    function plot_optimize(div){
        Plotly.d3.csv("{{ url_for('static', filename='rhodium_optimize.csv') }}", function (err, rows) {

            function unpack(rows, key) {
                return rows.map(function (row) {
                    return row[key];
                });
            }

            function unpack_size(rows, key) {
                return rows.map(function (row) {
                    return Math.round(row[key] *100000 ) - 2000;
                });
            }

            var data = [{
                x: unpack(rows, 'performance'),
                y: unpack(rows, 'cost'),
                z: unpack(rows, 'risk'),
                text: unpack(rows, 'policy_names'),
                mode: 'markers',
                type: 'scatter3d',
                marker: {
                    opacity: 0.8,
                    size: 5
                },
                hovertemplate:
                "Cost: %{y}<br>" +
                "Performance: %{x}<br>" +
                "Risk: %{z}<br>"
            }];
            console.log(data);

            var layout = {
                autosize: true,
                height: 800,
                scene:{
                    xaxis: {
                        title: 'Performance',
                        type: 'linear',
                        zeroline: false
                    },
                    yaxis: {
                        title: 'Cost',
                        type: 'linear',
                        zeroline: false
                    },
                    zaxis: {
                        title: 'Risk',
                        type: 'linear',
                        zeroline: false
                    }
                },
                title: {
                    text: 'Optimal Policies in Uncertainty',
                    font: {
                        size: 18,
                    }
                }
            };

            Plotly.newPlot(div, data, layout, {displayModeBar: false});

            document.getElementById(div).on('plotly_click', function(data){
                var pts = '';
                for(var i=0; i < data.points.length; i++){
                    pts = 'Performance: '+data.points[i].x +'\n' +
                          'Cost: '+ data.points[i].y + '\n' +
                          'Risk: ' + data.points[i].z + '\n\n' +
                          'Policy: ' + data.points[i].text + '\n';
                }
                alert('Policy Selected:\n\n'+pts);
            });
        });
    }

    function plot_policy_eval(div) {

        Plotly.d3.csv("{{ url_for('static', filename='rhodium_policy_eval.csv') }}", function (err, rows) {

            var perf = [], cost = [], risk = [], numOfUsers = [], latitude = [], sampEn = [], rainfall = [], index = [], color = [], opacity = []
            var colorway = ['#000000','#f8a6c1' ,'#ec4ac0','#fcaf50','#f3cec9', '#e7a4b6', '#cd7eaf', '#a262a9', '#6f4d96', '#50fc67', '#182844']

            for (var i = 0; i < rows.length; i++) {
                let row = rows[i];
                perf.push(row["performance"]);
                cost.push(row["cost"]);
                risk.push(row["risk"]);
                numOfUsers.push(Math.abs(row["numOfUsers"] - 1000));
                latitude.push(row["latitude"]);
                sampEn.push(Math.abs(row["sampEn"] - 2.68) * 300);
                rainfall.push(row["rainfall"]);
                index.push(row["index"]);

                if(row["performance"] >= perf_range[0] && row["performance"] <= perf_range[1] &&
                    row["cost"] >= cost_range[0] * 1000 && row["cost"] <= cost_range[1] * 1000 &&
                    row["risk"] >= risk_range[0] && row["risk"] <= risk_range[1]) {
                    opacity.push(0.6)
                    color.push(colorway[Number(row["index"]) + 1]);
                }else{
                    opacity.push(0.3)
                    color.push(colorway[0])
                }
            }


            var data = [{
                x: perf,
                y: cost,
                z: risk,
                numOfUsers: numOfUsers,
                latitude: latitude,
                sampEn: sampEn,
                rainfall: rainfall,
                mode: 'markers',
                type: 'scatter3d',
                marker: {
                    color: color,
                    opacity: opacity,
                    size: sampEn,
                    sizeref: 10,
                    line:{
                        opacity: 0.1,
                        color: color
                    }
                },
                transforms: [{ type: "groupby", groups: index }],
                hovertemplate:
                "Cost: %{y}<br>" +
                "Performance: %{x}<br>" +
                "Risk: %{z}<br>"
            }];
            console.log(index);

            var layout = {
                autosize: true,
                height: 800,
                scene: {
                    aspectratio: {
                        x: 1,
                        y: 1,
                        z: 1
                    },
                    camera: {
                        center: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        eye: {
                            x: 1.25,
                            y: 1.25,
                            z: 1.25
                        },
                        up: {
                            x: 0,
                            y: 0,
                            z: 1
                        }
                    },
                    xaxis: {
                        title: 'Performance',
                        type: 'linear',
                        zeroline: false
                    },
                    yaxis: {
                        title: 'Cost',
                        type: 'linear',
                        zeroline: false
                    },
                    zaxis: {
                        title: 'Risk',
                        type: 'linear',
                        zeroline: false
                    }
                },
                title: {
                    text: 'Evaluation of Optimal Policies in Uncertainty',
                    font: {
                        size: 18,
                    }
                }
            };

            Plotly.newPlot(div, data, layout, {displayModeBar: false});

            document.getElementById(div).on('plotly_click', function(data){
                var pts = '';
                for(var i=0; i < data.points.length; i++){
                    pts = 'Performance: '+data.points[i].x +'\n' +
                          'Cost: '+ data.points[i].y + '\n' +
                          'Risk: ' + data.points[i].z + '\n\n' +
                          'Uncertainty: \n' +
                          'Number of Users: ' + data.points[i].data.numOfUsers[i] + '\n' +
                          'Latitude: ' + data.points[i].data.latitude[i] + '\n' +
                          'Rainfall: ' + data.points[i].data.rainfall[i] + '\n' +
                          'SampEn: ' + data.points[i].data.sampEn[i] + '\n';
                }
                alert('Policy Selected:\n\n'+pts);
            });
        });
    }

</script>

<script id="visual1">
    const svg = d3.select("svg#scatterplot");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margins = {"top": 10, "right": 10, "bottom": 50, "left": 50}; // Can leave out quotes
    const chartWidth = width - margins.left - margins.right;
    const chartHeight = height - margins.top - margins.bottom;

    let scatter = svg.append("g")
                    .attr("transform","translate("+margins.left+","+margins.top+")");


    // 1. Import some CSV data
    // We're going to use d3.csv, which loads data from the web. It returns a "promise" that some time in the future it will have the data
    // .then is triggered by the promise if it successfully calls back
    // otherwise an error may be recorded

    // This is important because it allows us to work "asynchronously" and not hold up the browser
    // We'll see another construction that's even more flexible later this term (async + await)

    // .then( function(successfulResult), function(errorMessage) )
    d3.csv("{{ url_for('static', filename='gapminder.csv') }}")
      .then( (data) => {

    console.log(data)

    // 2. Check for data issues

    // Let's fix some things up
    data.forEach( (d, i) => {
      d['life'] = Number(d['Life Expectancy']);
      d['gdp'] = Number(d['GDP/Person (PPP$)']);
      // d['Total Population'] = Number(d['Total Population']); // This will pump out NaNs. Why?
      d['pop'] = Number(d['Total Population'].replace(/,/g,"")); // Fix with replace for commas
    });

    // See stuff below 5
    data = data.filter( (d) => {return d['gdp'] != 0 && d['life'] != 0 && d['pop'] != 0;}  );
    console.log(data)


    // 3. Let's build some scales
    const gdpMin = d3.min(data, (d) => {return d['gdp'];} );
      // d3.minmax takes in two params, first is the array, second is the "getter" function for each element -- you have to tell d3.max what values you want it to inspect
    const gdpMax = d3.max(data, (d) => {return d['gdp'];} );
    const gdpScale = d3.scaleLinear().domain([gdpMin+1, gdpMax]).range([0, chartWidth]);

    const lifeMin = d3.min(data, (d) => {return d['life'];} );
    const lifeMax = d3.max(data, (d) => {return d['life'];} );
    const lifeScale = d3.scaleLinear().domain([lifeMin, lifeMax])
                        .range([chartHeight, 0]); // invert height for coord system!

    const popMin = d3.min(data, (d) => {return d['pop'];} );
    const popMax = d3.max(data, (d) => {return d['pop'];} );
    const popScale = d3.scaleLinear().domain([popMin, popMax]).range([5,10]); // circle size

    // Yes, the (d) => {return d['pop'];} stuff gets clunky. I'm doing it mainly to reinforce that you are sending functions to d3.max and d3.min

    // We'll check out the alternate formulation, d => d['pop'] on Monday
    //   Hint: you can use this style when your function is returning a value immediately


    // 5. Start plotting circles and see what happens
    data.forEach( (d, i) => {

      scatter.append("circle")
          .attr("cx", gdpScale(d['gdp']))
          .attr("cy", lifeScale(d['life']))
          .attr("r", popScale(d['pop']))
          .attr("opacity", 0.8)
          .attr("index", i)  // I usually include the index as an extra attr so that if points look weird, I can find out what's going on in the datasets
          .style("fill", "steelblue");

    });


    // See that it looks VERY weird --
    //  EXAMINE INDEX 177
    // add:
    // data = data.filter( (d) => {return d['gdp'] != 0;}  );
    // This fixes a few points, but there are still 0s skewing our scales.
    // Check again and find a life expectancy of 0 too which we have to fix
    // data = data.filter( (d) => {return d['gdp'] != 0 && d['life'] != 0 && d['pop'] != 0;}  );

    // array.filter is a builtin JS function
    // It loops through the array, making a new array based on filter criteria
    // You give it a function that takes in an object and returns true if it should stick around or false if the object should be eliminated by the filter
    //  We use && here because we want to make sure our points have good values for ALL of those keys

    // We'll put the filter command before we set the scales


    // 4. Let's add some axes
    // We're going to use D3's axis tools to do it
    let leftAxis = d3.axisLeft(lifeScale);
    svg.append("g")
      .attr("class", "y axis")
      .attr("transform","translate("+(margins.left-10)+","+margins.top+")")
      .call(leftAxis);

    // Why do we use call? It's because axisBottom returns a function that we want to execute
    // You can think of d3.axis as giving you a function that "pastes" the axis labels into an element
    //  By running the axis function on an SVG group, we "paste" some new SVG elements into the group
    // Call is just shorthand for "run this function on the current entity we're chaining"
    let bottomAxis = d3.axisBottom(gdpScale).ticks(6)  // .ticks tells it how many ticks to draw
    let element = svg.append("g")
                    .attr("class", "y axis")
                    .attr("transform","translate("+margins.left+","+(chartHeight+margins.top+10)+")");
    bottomAxis(element); // this is how you'd replace .call(bottomAxis) -- don't do this!



    // 5A. We can manually make some gridlines
    //  It would work fine for HW3, but I don't recommend it once you start using axis labels

    // for (let i=0; i <= chartWidth; i = i + chartWidth/10) {
    //     scatter.append("line")
    //       .attr("x1",i)
    //       .attr("x2",i)
    //       .attr("y1",0)
    //       .attr("y2",chartHeight)
    //       .attr("stroke","lightgrey")
    //       .attr("stroke-width","1px");
    // }

    // 5B. Or we can use axes in a clever way
    //  Create the axis
    //   Configure it so that tickFormat is empty (don't make text labels)
    //   Set tickSize to be a negative number, so instead of hanging below the chart the gridlined extend back into it

    //  FINALLY, don't forget to use CSS to configure the gridlines a bit
    //   You will want to make the <line> elements a bit lighter and hide the element that has class .domain (that's the perpendicular line that connects the ticks)
    //   See CSS in head of this file for example
    let leftGridlines = d3.axisLeft(lifeScale)
                          .tickSize(-chartWidth-10)
                          .tickFormat("");
    // Notice how we use a different class
    svg.append("g").attr("class", "y gridlines") // See CSS at top of file
      .attr("transform","translate("+ (margins.left-10) +","+ margins.top +")")
      .call(leftGridlines);
    // Make sure to set a gridlines class so you can distinguish it from your axes when styling


    // The real benefit is that you can use the same configurations on your gridline axis that you used on your label axis. For example, we can put a tick number here
    let bottomGridlines = d3.axisBottom(gdpScale)
                            .tickSize(-chartHeight-10)
                            .tickFormat("")
                            .ticks(6); // Borrowing from our axis labels
    svg.append("g").attr("class", "x gridlines") // See CSS at top of file
      .attr("transform","translate("+margins.left+","+(chartHeight+margins.top+10)+")")
      .call(bottomGridlines);


    // NOTE: Our gridlines show up on top of the points. In practice you'll want to draw the circles last, or make an SVG group to hold the axes and then make your chart group after.

    // Next up: filtering, legends, and advanced formatting


    // The second parameter of a .then() returns an error -- handle it gracefully
    }, (error) => {
    console.log(error);
    } );

</script>

{% endblock %}